version: '3.9'

services:
  # Api-Gateway Service Definition
  api-gateway:
    build:
      context: ./api-gateway
      dockerfile: api-gateway.dockerfile
    image: api-gateway-image
    container_name: api-gateway
    restart: always
    depends_on:
      - order-service
    ports:
      - "3000:3000"  # Adjust based on your actual API port
    env_file:
      - .env
    networks:
      - mynetwork


  # Order Service Definition
  order-service:
    build:
      context: ./../order-service  # Path to the order service code
      dockerfile: ./../order-service/order-service.dockerfile  # Dockerfile for building the order service
    image: ${ORDER_SERVICE_IMAGE_NAME}  # Name of the Docker image for order service
    container_name: ${ORDER_SERVICE_CONTAINER_NAME}  # Container name for order service
    restart: always  # Restart the container automatically if it stops
    depends_on:
      order-db:
        condition: service_healthy  # Wait for the order database to be healthy before starting the service
      rabbitmq:
        condition: service_healthy  # Wait for RabbitMQ to be ready before starting the service
    ports:
      - "${ORDER_SERVICE_PORT}:${ORDER_SERVICE_PORT}"  # Map the order service port from the host to the container
    env_file:
      - .env  # Load environment variables from .env file
    networks:
      - mynetwork  # Connect the service to the network


  # Order Database Definition
  order-db:
    image: postgres:15  # Use the official PostgreSQL image version 15
    container_name: ${ORDER_POSTGRES_DB_CONTAINER_NAME}  # Container name for order database
    restart: always  # Restart the container automatically if it stops
    environment:
      POSTGRES_USER: ${ORDER_POSTGRES_DB_USER}  # PostgreSQL ordername
      POSTGRES_PASSWORD: ${ORDER_POSTGRES_DB_PASSWORD}  # PostgreSQL password
      POSTGRES_DB: ${ORDER_POSTGRES_DB_NAME}  # Name of the PostgreSQL database
    ports:
      - "${ORDER_POSTGRES_DB_PORT}:5432"  # Map PostgreSQL port from the host to the container
    healthcheck:  # Health check to ensure PostgreSQL is ready before starting order service
      test: ["CMD", "pg_isready", "-U", "${ORDER_POSTGRES_DB_USER}", "-d", "${ORDER_POSTGRES_DB_NAME}"]
      interval: 15s  # Interval between checks
      timeout: 5s  # Timeout duration
      retries: 10  # Number of retries before considering the service as unhealthy
    volumes:
      - order_db_data:/var/lib/postgresql/data  # Persistent storage for PostgreSQL data
    networks:
      - mynetwork  # Connect the service to the network


  # RabbitMQ Definition
  rabbitmq:
    image: rabbitmq:3-management
    container_name: ${RABBITMQ_CONTAINER_NAME}
    restart: always
    environment:
      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER}  # Set from .env
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASS}  # Set from .env
    ports:
      - "${RABBITMQ_PORT}:${RABBITMQ_PORT}"  # RabbitMQ message broker port
      - "${RABBITMQ_MANAGEMENT_UI}:${RABBITMQ_MANAGEMENT_UI}"  # Management UI      
    volumes:
      - rabbitmq_db_data:/var/lib/rabbitmq    
    healthcheck:  # Health check for RabbitMQ to ensure it's up before usage
      test: ["CMD", "rabbitmqctl", "status"]
      interval: 10s
      retries: 10
    networks:
      - mynetwork  # Connect the service to the network

# Database Volumes
volumes:
  order_db_data:         # Define volume for order database data
  rabbitmq_db_data:      # Define volume for rabbitmq database data

# Networks Definition
networks:
  mynetwork:
    driver: bridge